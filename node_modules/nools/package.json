{
  "name": "nools",
  "description": "A rules engine for node",
  "version": "0.3.0",
  "bin": {
    "nools": "./bin/nools"
  },
  "keywords": [
    "rules",
    "flow",
    "rules engine",
    "rools",
    "drools",
    "async",
    "flow control"
  ],
  "repository": {
    "type": "git",
    "url": "git@github.com:C2FO/nools.git"
  },
  "dependencies": {
    "declare.js": "~0.0.3",
    "extended": "~0.0.3",
    "is-extended": "~0.0.4",
    "string-extended": "~0.0.3",
    "array-extended": "~0.0.4",
    "date-extended": "~0.0.3",
    "function-extended": "~0.0.3",
    "object-extended": "~0.0.3",
    "promise-extended": "~0.0.3",
    "arguments-extended": "~0.0.3",
    "leafy": "~0.0.3",
    "ht": "~0.0.2",
    "commander": "~1.1.1",
    "uglify-js": "~2.3.6"
  },
  "devDependencies": {
    "grunt": "~0.4.1",
    "it": "~0.2.0",
    "jison": ">=0.3.2",
    "grunt-it": "~0.3.0",
    "grunt-contrib-uglify": "~0.2.0",
    "grunt-contrib-jshint": "~0.5.3",
    "grunt-browserify": "1.2.4",
    "grunt-exec": "^0.4.5"
  },
  "testling": {
    "files": "test/browserling.js",
    "browsers": [
      "ie/8..latest",
      "chrome/20..latest",
      "firefox/14..latest",
      "safari/latest",
      "iphone/6",
      "ipad/6"
    ]
  },
  "homepage": "http://c2fo.github.com/nools",
  "author": {
    "name": "Doug Martin",
    "url": "http://c2fo.com"
  },
  "main": "index.js",
  "scripts": {
    "test": "it -r dot",
    "create-doc": "rm -rf docs/* && coddoc -d ./lib -f multi-html"
  },
  "directories": {
    "lib": "lib"
  },
  "engines": {
    "node": ">= 0.6.1"
  },
  "readme": "[![Build Status](https://travis-ci.org/C2FO/nools.png)](https://travis-ci.org/C2FO/nools)\n\n[![browser support](https://ci.testling.com/C2FO/nools.png)](https://ci.testling.com/C2FO/nools)\n\n# Nools\n\nNools is a [rete](http://en.wikipedia.org/wiki/Rete_algorithm) based rules engine written entirely in javascript.\n\n# Installation\n\n```\nnpm install nools\n```\nOr [download the source](https://raw.github.com/C2FO/nools/master/nools.js) ([minified](https://raw.github.com/C2FO/nools/master/nools.min.js))\n\n\n# Usage\n\n   * Flows\n    * [Defining A Flow](#flow)\n    * [Sessions](#session)\n    * [Facts](#facts)\n        * [Assert](#facts-assert)\n        * [Retract](#facts-retract)\n        * [Modify](#facts-modify)\n        * [Retrieving Facts](#get-facts)\n    * [Firing](#firing)\n    * [Disposing](#disposing)\n    * [Removing A Flow](#removing-flow)\n    * [Removing All Flows](#removing-flows)\n    * [Checking If A Flow Exists](#checking-for-flow)\n    * [Agenda Group](#agenda-groups)\n      * [Focus](#agenda-groups-focus)\n      * [Auto Focus](#agenda-groups-auto-focus)\n    * [Conflict Resolution](#conflict-resolution)\n   * [Defining Rules](#defining-rule)\n      * [Structure](#rule-structure)\n      * [Salience](#rule-salience)\n      * [Scope](#rule-scope)\n      * [Constraints](#constraints)\n        * [Not](#not-constraint)\n        * [Or](#or-constraint)\n        * [From](#from-constraint)\n        * [Exists](#exists-constraint)\n      * [Actions](#action)\n        * [Async Actions](#action-async)\n      * [Globals](#globals)\n      * [Import](#import)\n   * [Browser Support](#browser-support)\n   * [Fibonacci](#fib)\n\n## Resources\n  * [Nools Google group](https://groups.google.com/forum/#!forum/nools)\n  * [Examples](http://c2fo.github.io/nools/examples.html)\n    * [Conways 2D](http://c2fo.github.io/nools/examples/browser/conways_2d.html)\n    * [Conways 3D](http://c2fo.github.io/nools/examples/browser/conways_3d.html)\n    * [Sudoku](http://c2fo.github.io/nools/examples/browser/sudoku.html)\n    * [Fibonacci](http://c2fo.github.io/nools/examples/browser/fibonacci.html)\n    * [Miss Manners](http://c2fo.github.io/nools/examples/browser/manners.html)\n    * [Waltz DB](http://c2fo.github.io/nools/examples/browser/waltzDb.html)\n    * [Send More Money](http://c2fo.github.io/nools/examples/browser/sendMoreMoney.html)\n    * [Diagnosis](http://c2fo.github.io/nools/examples/browser/diagnose.html)\n  * [Tests](https://github.com/C2FO/nools/tree/master/test)\n\n<a name=\"flow\"></a>\n## Defining a flow\n\nWhen using nools you define a **flow** which acts as a container for rules that can later be used to get\na **session**\n\n### Programmatically\n```javascript\nvar nools = require(\"nools\");\n\nvar Message = function (message) {\n    this.text = message;\n};\n\nvar flow = nools.flow(\"Hello World\", function (flow) {\n\n    //find any message that start with hello\n    flow.rule(\"Hello\", [Message, \"m\", \"m.text =~ /^hello(\\\\s*world)?$/\"], function (facts) {\n        facts.m.text = facts.m.text + \" goodbye\";\n        this.modify(facts.m);\n    });\n\n    //find all messages then end in goodbye\n    flow.rule(\"Goodbye\", [Message, \"m\", \"m.text =~ /.*goodbye$/\"], function (facts) {\n        console.log(facts.m.text);\n    });\n});\n\n```\n\nIn the above flow definition 2 rules were defined\n\n  * Hello\n    * Requires a Message\n    * The messages's `text` must match the regular expression `/^hello(\\\\s*world)?$/`\n    * When matched the message's `text` is modified and then we let the engine know that we modified the message.\n  * Goodbye\n    * Requires a Message\n    * The messages's `text` must match the regular expression `/.*goodbye$/`(anything that ends in goodbye)\n    * When matched the resulting message is logged.\n\n### DSL\n\nYou may also use the `nools` rules language to define your rules.\n\nThe following is the equivalent of the rules defined programmatically above.\n\n```\ndefine Message {\n    text : '',\n    constructor : function(message){\n        this.text = message;\n    }\n}\n\n//find any message that starts with hello\nrule Hello {\n    when {\n        m : Message m.text =~ /^hello(\\s*world)?$/;\n    }\n    then {\n        modify(m, function(){this.text += \" goodbye\";});\n    }\n}\n\n//find all messages then end in goodbye\nrule Goodbye {\n    when {\n        m : Message m.text =~ /.*goodbye$/;\n    }\n    then {\n        console.log(m.text);\n    }\n}\n```\n\nTo use the flow\n\n```javascript\nvar flow = nools.compile(__dirname + \"/helloworld.nools\"),\n    Message = flow.getDefined(\"message\");\n```\n\n### Flow Events\n\nEach flow can have the following events emitted.\n\n* `assert (fact)` - emitted when facts are asserted\n* `retract (fact)` - emitted when facts are retracted\n* `modify (fact)` - emitted when facts are modified\n* `fire (name, rule)` - emitted when an activation is fired.\n\n```\nsession.on(\"assert\", function(fact){\n    //fact was asserted\n});\n\nsession.on(\"retract\", function(fact){\n    //fact was retracted\n});\n\nsession.on(\"modify\", function(fact){\n    //fact was modifed\n});\n\nsession.on(\"fire\", function(name, rule){\n    //a rule was fired.\n});\n```\n\n### `nools.compile`\n\nThe compile method accepts the following parameters\n\n* `source|path` - The first argument must either be a path that ends in `.nools` or a string which is the source of the rules that you wish to compile.\n* `options?`\n   * `name` : This is the name of the flow. You can use this name to look up the flow by using `nools.getFlow`.\n   * `define` : A hash of Classes that should be aviable to the rules that you are compiling.\n   * `scope`: A hash of items that should be available to rules as they run. (i.e. a logger)\n* `cb?` - an options function to invoke when compiling is done.\n\n\n**Example**\n\n```\nrule \"person name is bob\" {\n    when {\n        p : Person p.name == 'bob';\n    }\n    then {\n        logger.info(\"Found person with name of bob\");\n        retract(p);\n    }\n}\n```\n\nIn the above rules file we make use of a Person class and a logger. In order for nools to properly reference the Class and logger you must specify them in your options.\n\n```javascript\nvar flow = nools.compile(\"personFlow.nools\", {\n    define: {\n        //The person class the flow should use\n        Person: Person\n    },\n    scope: {\n        //the logger you want your flow to use.\n        logger: logger\n    }\n});\n```\n\nYou may also compile source directly.\n\n```javascript\nvar noolsSource = \"rule 'person name is bob' {\"\n    + \"   when {\"\n    + \"     p : Person p.name == 'bob';\"\n    + \"   }\"\n    + \"   then {\"\n    + \"       logger.info('Found person with name of bob');\"\n    + \"       retract(p);\"\n    + \"   }\"\n    + \"}\";\n\nvar flow = nools.compile(noolsSource, {\n    define: {\n        //The person class the flow should use\n        Person: Person\n    },\n    scope: {\n        //the logger you want your flow to use.\n        logger: logger\n    }\n});\n```\n\n<a name=\"session\"></a>\n## Working with a session\n\nA session is an instance of the flow that contains a working memory and handles the assertion, modification, and retraction of facts from the engine.\n\nTo obtain an engine session from the flow invoke the  `getSession` method.\n\n```javascript\nvar session = flow.getSession();\n```\n\n<a name=\"facts\"></a>\n## Working with facts\n\nFacts are items that the rules should try to match.\n\n<a name=\"facts-assert\"></a>\n### Assert\n\nTo add facts to the session use `assert` method.\n\n```javascript\nsession.assert(new Message(\"hello\"));\nsession.assert(new Message(\"hello world\"));\nsession.assert(new Message(\"goodbye\"));\n```\n\nAs a convenience any object passed into **getSession** will also be asserted.\n\n**Note** assert is typically used pre engine execution and during the execution of the rules.\n\n```javascript\nflow.getSession(new Message(\"hello\"), new Message(\"hello world\"), new Message(\"goodbye\"));\n```\n\n<a name=\"facts-retract\"></a>\n### Retract\n\nTo remove facts from the session use the `retract` method.\n\n```javascript\nvar m = new Message(\"hello\");\n\n//assert the fact into the engine\nsession.assert(m);\n\n//remove the fact from the engine\nsession.retract(m);\n\n```\n\n**Note** `retract` is typically used during the execution of the rules.\n\n<a name=\"facts-modify\"></a>\n### Modify\n\n\nTo modify a fact use the `modify` method.\n\n**Note** modify will not work with immutable objects (i.e. strings).\n\n```javascript\n\nvar m = new Message(\"hello\");\n\nsession.assert(m);\n\nm.text = \"hello goodbye\";\n\nsession.modify(m);\n\n```\n\n**Note** `modify` is typically used during the execution of the rules.\n\n<a name=\"get-facts\"></a>\n### Retrieving Facts\n\nTo get a list of facts currently in the session you can use the `getFacts()` method exposed on a session.\n\n```javascript\nsession.assert(1);\nsession.assert(\"A\");\nsession.assert(\"B\");\nsession.assert(2);\n\nsession.getFacts(); //[1, \"A\", \"B\", 2];\n```\n\nYou may also pass in a `Type` to `getFacts` which will return facts only of the given type.\n\n```javascript\nsession.assert(1);\nsession.assert(\"A\");\nsession.assert(\"B\");\nsession.assert(2);\n\nsession.getFacts(Number); //[1, 2];\nsession.getFacts(String); //[\"A\", \"B\"];\n```\n\n\n<a name=\"firing\"></a>\n## Firing the rules\n\nWhen you get a session from a **flow** no rules will be fired until the **match** method is called.\n\n```javascript\nvar session = flow.getSession();\n//assert your different messages\nsession.assert(new Message(\"goodbye\"));\nsession.assert(new Message(\"hello\"));\nsession.assert(new Message(\"hello world\"));\n\n//now fire the rules\nsession.match(function(err){\n    if(err){\n        console.error(err.stack);\n    }else{\n        console.log(\"done\");\n    }\n})\n```\n\nThe **match** method also returns a promise that is resolved once there are no more rules to activate.\n\n```javascript\nsession.match().then(\n  function(){\n      console.log(\"Done\");\n  },\n  function(err){\n    //uh oh an error occurred\n    console.error(err.stack);\n  });\n```\n\n## Fire until halt\n\nYou may also run the engine an a \"reactive\" mode which will continue to match until `halt` is invoked.\n\nIn the following example the rules engine continues to evaluate until the counter reaches `10000`. If you remove the \"counted to high\" rule then the engine would run indefinitely.\n\n```javascript\n\ndefine Counter {\n    count: 0,\n    constructor: function(count){\n        this.count = count;\n    }\n}\n\n//We reached our goal\nrule \"I can count!\" {\n    when {\n        $ctr: Counter $ctr.count == 10000;\n    }\n    then{\n        console.log(\"Look ma! I counted to \" + $ctr.count);\n        halt();\n    }\n}\n\n//no counter was asserted so create one\nrule \"not count\" {\n    when {\n        not($ctr: Counter);\n    }\n    then{\n        console.log(\"Imma gonna count!\");\n        assert(new Counter(1));\n    }\n}\n\n//A little status update\nrule \"give them an update\" {\n    when{\n        $ctr: Counter $ctr.count % 1000 == 0 {count: $count}\n    }\n    then{\n        console.log(\"Imma countin...\");\n        modify($ctr, function(){this.count = $count + 1;});\n    }\n}\n\n//just counting away\nrule count {\n    when{\n        $ctr: Counter {count: $count}\n    }\n    then{\n        modify($ctr, function(){\n          this.count = $count + 1;\n        });\n    }\n}\n\n```\n\n```javascript\nflow.getSession().matchUntilHalt(function(err){\n    if(err){\n        console.log(err.stack);\n        return;\n    }\n    //halt finally invoked\n});\n```\n\n`matchUntilHalt` also returns a promise.\n\n\n```javascript\nflow.getSession().matchUntilHalt()\n    .then(\n        function(){\n            //all done!\n        },\n        function(err){\n            console.log(err.stack);\n        }\n    );\n```\n\n\n\n<a name=\"disposing\"></a>\n## Disposing of the session\n\nWhen working with a lot of facts it is wise to call the `dispose` method which will purge the current session of\nall facts, this will help prevent the process from growing a large memory footprint.\n\n```javascript\nsession.dispose();\n```\n\n<a name=\"removing-flow\"></a>\n# Removing a flow\n\nTo remove a defined flow from `nools` use the `deleteFlow` function.\n\n```javascript\nvar myFlow = nools.flow(\"flow\");\n\nnools.deleteFlow(\"flow\"); //returns nools for chaining\n\nnools.getFlow(\"flow\"); //undefined\n\n```\n\nYou may also remove a flow using the `FlowContainer` object returned from nools.flow;\n\n```javascript\nvar myFlow = nools.flow(\"flow\");\n\nnools.deleteFlow(myFlow); //returns nools for chaining\n\nnools.getFlow(\"flow\"); //undefined\n```\n\n<a name=\"removing-flows\"></a>\n# Removing All Flows\n\nTo remove all flow from `nools` use the `deleteFlows` function.\n\n```javascript\nvar myFlow = nools.flow(\"flow\");\n\nnools.deleteFlows(); //returns nools for chaining\n\nnools.getFlow(\"flow\"); //undefined\n\n```\n\n\n<a name=\"checking-for-flow\"></a>\n# Checking If A Flow Exists\n\nTo check if a flow currently is registering with `nools` use the `hasFlow` function;\n\n```javascript\nvar myFlow = nools.flow(\"flow\");\n\nnools.hasFlow(\"flow\"); //true\n\n```\n\n<a name=\"agenda-groups\"></a>\n## Agenda Groups\n\nAgenda groups allow for logical groups of rules within a flow.\n\nThe agenda manages a `stack` of `agenda-groups` that are currently in focus. The default `agenda-group` is called `main` and all rules that do not have an `agenda-group` specified are placed into the `main` `agenda-group`.\n\nAs rules are fired and a particular `agenda-group` runs out of activations then that `agenda-group` is popped from the internal `agenda-group` stack and the next one comes into focus. This continues until `focus` is explicitly called again or the `main` `agenda-group` comes into focus.\n\n**Note** Once an agenda group loses focus it must be re-added to the stack in order for those activations to be focused again.\n\nTo add a rule to an agenda-group you can use the `agendaGroup` option.\n\n```javascript\nthis.rule(\"Hello World\", {agendaGroup: \"ag1\"}, [Message, \"m\", \"m.name == 'hello'\"], function (facts) {\n    this.modify(facts.m, function () {\n        this.name = \"goodbye\";\n    });\n});\n\nthis.rule(\"Hello World2\", {agendaGroup: \"ag2\"}, [Message, \"m\", \"m.name == 'hello'\"], function (facts) {\n    this.modify(facts.m, function () {\n        this.name = \"goodbye\";\n    });\n});\n```\n\nOr in the dsl\n\n```\nrule \"Hello World\" {\n    agenda-group: \"ag1\";\n    when{\n        m : Message m.name === 'hello';\n    }\n    then{\n        modify(m, function(){\n            this.name = \"goodbye\";\n        });\n    }\n}\nrule \"Hello World 2\" {\n    agenda-group: \"ag2\";\n    when{\n        m : Message m.name === 'goodbye';\n    }\n    then {\n        modify(m, function(){\n            m.name = \"hello\";\n        });\n    }\n}\n```\n\nIn the above rules we have defined two agenda-groups called `ag1` and `ag2`\n\n<a name=\"agenda-groups-focus\"></a>\n### Focus\n\nWhen running your rules and you want a particular agenda group to run you must call `focus` on the session of the flow and specify the `agenda-group` to add to the stack.\n\n```\n//assuming a flow with the rules specified above.\nvar fired = [];\nflow.getSession(new Message(\"hello\"))\n    .focus(\"ag1\")\n    .on(\"fire\", function (ruleName) {\n        fired.push(ruleName);\n    })\n    .match(function () {\n        console.log(fired);  //[ 'Hello World' ]\n    });\n```\n\nOr you can add multiple `agenda-groups` to the focus stack.\n\n```javascript\nvar fired1 = [], fired2 = [];\nflow\n    .getSession(new Message(\"goodbye\"))\n    .focus(\"ag1\")\n    .focus(\"ag2\")\n    .on(\"fire\", function (ruleName) {\n        fired1.push(ruleName);\n    })\n    .match(function () {\n        console.log(\"Example 1\", fired1); //[ 'Hello World', 'Hello World2' ]\n    });\nflow\n    .getSession(new Message(\"hello\"))\n    .focus(\"ag2\")\n    .focus(\"ag1\")\n    .on(\"fire\", function (ruleName) {\n        fired3.push(ruleName);\n    })\n    .match(function () {\n        console.log(\"Example 2\", fired2); //[ 'Hello World', 'Hello World2' ]\n    });\n```\n\nNotice above that the **last** `agenda-group` focused is added to the array first.\n\n<a name=\"agenda-groups-auto-focus\"></a>\n### Auto Focus\n\nSometimes you may want an `agenda-group` to `auto-focus` whenever a certain rule is activated.\n\n```\nthis.rule(\"Bootstrap\", [State, \"a\", \"a.name == 'A' && a.state == 'NOT_RUN'\"], function (facts) {\n    this.modify(facts.a, function () {\n        this.state = 'FINISHED';\n    });\n});\n\nthis.rule(\"A to B\",\n    [\n        [State, \"a\", \"a.name == 'A' && a.state == 'FINISHED'\"],\n        [State, \"b\", \"b.name == 'B' && b.state == 'NOT_RUN'\"]\n    ],\n    function (facts) {\n        this.modify(facts.b, function () {\n            this.state = \"FINISHED\";\n        });\n    });\n\nthis.rule(\"B to C\",\n    {agendaGroup: \"B to C\", autoFocus: true},\n    [\n        [State, \"b\", \"b.name == 'B' && b.state == 'FINISHED'\"],\n        [State, \"c\", \"c.name == 'C' && c.state == 'NOT_RUN'\"]\n    ],\n    function (facts) {\n        this.modify(facts.c, function () {\n            this.state = 'FINISHED';\n        });\n        this.focus(\"B to D\");\n    });\n\nthis.rule(\"B to D\",\n    {agendaGroup: \"B to D\"},\n    [\n        [State, \"b\", \"b.name == 'B' && b.state == 'FINISHED'\"],\n        [State, \"d\", \"d.name == 'D' && d.state == 'NOT_RUN'\"]\n    ],\n    function (facts) {\n        this.modify(facts.d, function () {\n        this.state = 'FINISHED';\n    });\n});\n```\n\nOr using the dsl\n\n```\nrule Bootstrap {\n    when{\n        a : State a.name == 'A' && a.state == 'NOT_RUN';\n    }\n    then{\n        modify(a, function(){\n            this.state = 'FINISHED';\n        });\n    }\n}\n\n\nrule 'A to B' {\n    when{\n        a : State a.name == 'A' && a.state == 'FINISHED';\n        b : State b.name == 'B' && b.state == 'NOT_RUN';\n    }\n    then{\n        modify(b, function(){\n            this.state = 'FINISHED';\n        });\n    }\n}\n\nrule 'B to C' {\n    agenda-group: 'B to C';\n    auto-focus: true;\n    when{\n        b: State b.name == 'B' && b.state == 'FINISHED';\n        c : State c.name == 'C' && c.state == 'NOT_RUN';\n    }\n    then{\n        modify(c, function(){\n            this.state = 'FINISHED';\n        });\n        focus('B to D')\n    }\n}\n\nrule 'B to D' {\n    agenda-group: 'B to D';\n    when{\n        b: State b.name == 'B' && b.state == 'FINISHED';\n        d : State d.name == 'D' && d.state == 'NOT_RUN';\n    }\n    then{\n        modify(d, function(){\n            this.state = 'FINISHED';\n        });\n    }\n}\n```\n\nIn the above rules we created a state machine that has a rule with `auto-focus` set to true.\n\nThis allows you to not have to specify `focus` when running the flow.\n\n```javascript\nvar fired = [];\nflow\n    .getSession(\n        new State(\"A\", \"NOT_RUN\"),\n        new State(\"B\", \"NOT_RUN\"),\n        new State(\"C\", \"NOT_RUN\"),\n        new State(\"D\", \"NOT_RUN\")\n    )\n    .on(\"fire\", function (name) {\n        fired.push(name);\n    })\n    .match()\n    .then(function () {\n        console.log(fired); //[\"Bootstrap\", \"A to B\", \"B to C\", \"B to D\"]\n    });\n```\n\n<a name=\"conflict-resolution\"></a>\n## Conflict Resolution\n\nWhen declaring a flow it is defined with a default conflict resolution strategy. A conflict resolution strategy is used to determine which rule to activate when multiple rules are ready to be activated at the same time.\n\n### Resolution Strategies\n\n* `salience` - sort activations on the specified [`salience`](#rule-salience). (**NOTE** The default salience of a rule is 0).\n* `activationRecency` - sort activations on activation recency. This is a `LIFO` strategy the latest activation takes precedence.\n* `factRecency` - sort activations based on `fact` recency. Each time a fact is `asserted` or `modified` its recency is incremented.\n* `bucketCounter` - sort activations on the internal `bucket` counter. The bucket counter is incremented after an activation is fired and the internal `workingMemory` is altered.\n\nThe default conflict resolution strategy consists of `salience` and `activationRecency`.\n\n###Examples\n\n**Example 1**\n\n```\n//activation 1\n{\n    salience: 0,\n    activationRecency: 1\n}\n\n//activation 2\n{\n    salience: 0,\n    activationRecency: 2\n}\n\n```\n\nIn the above example activation 2 would be fired since it is the most recent activation and the rule salience is the same.\n\n**Example 2**\n\n```\n//activation 1\n{\n    salience: 1,\n    activationRecency: 1\n}\n\n//activation 2\n{\n    salience: 0,\n    activationRecency: 2\n}\n\n```\nIn this example activation 1 would fire because it has a greater salience\n\n###Overidding The Default Strategy\n\nTo override the default strategy you can use the `conflictResolution` method on a flow.\n\n```javascript\n\nvar flow = nools.flow(/**define your flow**/);\n\nflow.conflictResolution([\"salience\", \"factRecency\", \"activationRecency\"]);\n\n```\n\nThe combination of `salience`, `factRecency`, and `activationRecency` would do the following.\n\n1. Check if the salience is the same, if not use the activation with the greatest salience.\n2. If salience is the same check if fact recency is the same. The fact recency is determined by looping through the facts in each activation and until two different recencies are found. The activation with the greatest recency takes precendence.\n3. If fact recency is the same check the activation recency.\n\n\n**Example 1**\n\n```\n//activation 1\n{\n    salience: 2,\n    factRecency: [1,2,3],\n    activationRecency: 1\n}\n\n//activation 2\n{\n    salience: 1,\n    factRecency: [1,2,4],\n    activationRecency: 2\n}\n```\n\nIn this example activation 1 would fire because it's salience is the greatest.\n\n**Example 2**\n\n```\n//activation 1\n{\n    salience: 1,\n    factRecency: [1,2,3],\n    activationRecency: 1\n}\n\n//activation 2\n{\n    salience: 1,\n    factRecency: [1,2,4],\n    activationRecency: 2\n}\n```\n\nIn Example 2 activation 2 would fire because of the third recency entry.\n\n**Example 3**\n\n```\n//activation 1\n{\n    salience: 2,\n    factRecency: [1,2,3],\n    activationRecency: 1\n}\n\n//activation 2\n{\n    salience: 1,\n    factRecency: [1,2,3],\n    activationRecency: 2\n}\n```\n\nIn Example 3 activation 2 would fire because `salience` and `factRecency` are the same but activation 2's activation recency is greater.\n\n\n<a name=\"defining-rule\"></a>\n# Defining rules\n\n<a name=\"rule structure\"></a>\n## Rule structure\n\nLets look at the \"Calculate\" rule in the [Fibonacci](#fib) example\n\n```javascript\n   //flow.rule(type[String|Function], constraints[Array|Array[[]]], action[Function]);\n   flow.rule(\"Calculate\", [\n         //Type     alias  pattern           store sequence to s1\n        [Fibonacci, \"f1\",  \"f1.value != -1\", {sequence:\"s1\"}],\n        [Fibonacci, \"f2\", \"f2.value != -1 && f2.sequence == s1 + 1\", {sequence:\"s2\"}],\n        [Fibonacci, \"f3\", \"f3.value == -1 && f3.sequence == s2 + 1\"],\n        [Result, \"r\"]\n    ], function (facts) {\n        var f3 = facts.f3, f1 = facts.f1, f2 = facts.f2;\n        var v = f3.value = f1.value + facts.f2.value;\n        facts.r.result = v;\n        this.modify(f3);\n        this.retract(f1);\n    });\n```\n\nOr using the nools DSL\n\n```\nrule Calculate{\n    when {\n        f1 : Fibonacci f1.value != -1 {sequence:s1};\n        f2 : Fibonacci f2.value != -1 && f2.sequence == s1 + 1 {sequence:s2};\n        f3 : Fibonacci f3.value == -1 && f3.sequence == s2 + 1;\n    }\n    then {\n       modify(f3, function(){\n            this.value = f1.value + f2.value;\n       });\n       retract(f1);\n    }\n}\n```\n\n<a name=\"rule-salience\"></a>\n### Salience\n\nSalience is an option that can be specified on a rule giving it a priority and allowing the developer some control over conflict resolution of activations.\n\n```javascript\nthis.rule(\"Hello4\", {salience: 7}, [Message, \"m\", \"m.name == 'Hello'\"], function (facts) {\n});\n\nthis.rule(\"Hello3\", {salience: 8}, [Message, \"m\", \"m.name == 'Hello'\"], function (facts) {\n});\n\nthis.rule(\"Hello2\", {salience: 9}, [Message, \"m\", \"m.name == 'Hello'\"], function (facts) {\n});\n\nthis.rule(\"Hello1\", {salience: 10}, [Message, \"m\", \"m.name == 'Hello'\"], function (facts) {\n});\n```\n\nOr using the DSL\n\n```javascript\nrule Hello4 {\n    salience: 7;\n    when {\n        m: Message m.name == 'hello';\n    }\n    then {}\n}\n\nrule Hello3 {\n    salience: 8;\n    when {\n        m: Message m.name == 'hello';\n    }\n    then {}\n}\n\nrule Hello2 {\n    salience: 9;\n    when {\n        m: Message m.name == 'hello';\n    }\n    then {}\n}\n\nrule Hello1 {\n    salience: 10;\n    when {\n        m: Message m.name == 'hello';\n    }\n    then {}\n}\n\n```\n\nIn the above flow we define four rules each with a different salience, when a single message is asserted they will fire in order of salience (highest to lowest).\n\n```javascript\nvar fired = [];\nflow1\n    .getSession(new Message(\"Hello\"))\n    .on(\"fire\", function (name) {\n        fired.push(name);\n    })\n    .match()\n    .then(function(){\n        console.log(fired); //[\"Hello1\", \"Hello2\", \"Hello3\", \"Hello4\"]\n    });\n```\n\n\n\n<a name=\"rule-scope\"></a>\n### Scope\n\nScope allows you to access function from within your rules.\n\nIf you are using vanilla JS you can use the `scope` option when defining your rule.\n\n```javascript\n\nthis.rule(\"hello rule\", {scope: {isEqualTo: isEqualTo}},\n   [\n      [\"or\",\n         [String, \"s\", \"isEqualTo(s, 'hello')\"],\n         [String, \"s\", \"isEqualTo(s, 'world')\"]\n      ],\n      [Count, \"called\", null]\n   ],\n   function (facts) {\n      facts.called.called++;\n   });\n\n\n```\n\nIf you are using the dsl.\n\n```\nfunction matches(str, regex){\n    return regex.test(str);\n}\n\nrule Hello {\n    when {\n        m : Message matches(m.text, /^hello(\\\\s*world)?$/);\n    }\n    then {\n        modify(m, function(){\n            this.text += \" goodbye\";\n        })\n    }\n}\n\nrule Goodbye {\n    when {\n        m : Message matches(m.text, /.*goodbye$/);\n    }\n    then {\n    }\n}\n```\n\nOr you can pass in a custom function using the scope option in compile.\n\n```\nrule Hello {\n    when {\n        m : Message doesMatch(m.text, /^hello(\\\\s*world)?$/);\n    }\n    then {\n        modify(m, function(){\n            this.text += \" goodbye\";\n        })\n    }\n}\n\nrule Goodbye {\n    when {\n        m : Message doesMatch(m.text, /.*goodbye$/);\n    }\n    then {\n    }\n}\n```\n\nProvided the `doesMatch` function in the scope option of compile.\n\n```javascript\nfunction matches(str, regex) {\n   return regex.test(str);\n};\nvar flow = nools.compile(__dirname + \"/rules/provided-scope.nools\", {scope: {doesMatch: matches}});\n```\n\n<a name=\"constraints\"></a>\n### Constraints\n\nConstraints define what facts the rule should match. The constraint is a array of either a single constraint (i.e. Bootstrap rule) or an array of constraints(i.e. Calculate).\n\nProgrammatically\n\n```javascript\n[\n   //Type     alias  pattern           store sequence to s1\n  [Fibonacci, \"f1\", \"f1.value != -1\", {sequence:\"s1\"}],\n  [Fibonacci, \"f2\", \"f2.value != -1 && f2.sequence == s1 + 1\", {sequence:\"s2\"}],\n  [Fibonacci, \"f3\", \"f3.value == -1 && f3.sequence == s2 + 1\"],\n  [Result, \"r\"]\n]\n```\n\nUsing nools DSL\n\n```\nwhen {\n    f1 : Fibonacci f1.value != -1 {sequence:s1};\n    f2 : Fibonacci f2.value != -1 && f2.sequence == s1 + 1 {sequence:s2};\n    f3 : Fibonacci f3.value == -1 && f3.sequence == s2 + 1;\n    r  : Result;\n}\n```\n\n   1. Type -  is the Object type the rule should match. The available types are\n      * `String` - \"string\", \"String\", String\n      * `Number` - \"number\", \"Number\", Number\n      * `Boolean` - \"boolean\", \"Boolean\", Boolean\n      * `Date` - \"date\", \"Date\", Date\n      * `RegExp` - \"regexp\", \"RegExp\", RegExp\n      * `Array` - \"array\", \"Array\", [], Array\n      * `Object` - \"object\", \"Object\", \"hash\", Object\n      * Custom - any custom type that you define\n   2. Alias - the name the object should be represented as.\n   3. Pattern(optional) - The pattern that should evaluate to a boolean, the alias that was used should be used to reference the object in the pattern. Strings should be in single quotes, regular expressions are allowed. Any previously defined alias/reference can be used within the pattern. Available operators are.\n      * `&&`, `AND`, `and`\n      * `||`, `OR`, `or`\n      * `>`, `<`, `>=`, `<=`, `gt`, `lt`, `gte`, `lte`\n      * `==`, `===`, `!=`, `!==`, `=~`, `!=~`, `eq`, `seq`, `neq`, `sneq`, `like`, `notLike`\n      * `+`, `-`, `*`, `/`, `%`\n      * `-` (unary minus)\n      * `.` (member operator)\n      * `in` (check inclusion in an array)\n      * `notIn` (check that something is not in an array)\n      * Defined helper functions\n        * `now` - the current date\n        * `Date(year?, month?, day?, hour?, minute?, second?, ms?)` - creates a new `Date` object\n        * `lengthOf(arr, length)` - checks the length of an array\n        * `isTrue(something)` - check if something === true\n        * `isFalse(something)` - check if something === false\n        * `isRegExp(something)` - check if something is a `RegExp`\n        * `isArray(something)` - check if something is an `Array`\n        * `isNumber(something)` - check if something is an `Number`\n        * `isHash(something)` - check if something is strictly an `Object`\n        * `isObject(something)` - check if something is any type of `Object`\n        * `isDate(something)` - check if something is a `Date`\n        * `isBoolean(something)` - check if something is a `Boolean`\n        * `isString(something)` - check if something is a `String`\n        * `isUndefined(something)` - check if something is a `undefined`\n        * `isDefined(something)` - check if something is `Defined`\n        * `isUndefinedOrNull(something)` - check if something is a `undefined` or `null`\n        * `isPromiseLike(something)` - check if something is a \"promise\" like (containing `then`, `addCallback`, `addErrback`)\n        * `isFunction(something)` - check if something is a `Function`\n        * `isNull(something)` - check if something is `null`\n        * `isNotNull(something)` - check if something is not null\n        * `dateCmp(dt1, dt2)` - compares two dates return 1, -1, or 0\n        * `(years|months|days|hours|minutes|seconds)(Ago|FromNow)(interval)` - adds/subtracts the date unit from the current time\n\n   4. Reference(optional) - An object where the keys are properties on the current object, and values are aliases to use. The alias may be used in succeeding patterns.\n\n<a name=\"not-constraint\"></a>\n#### Not Constraint\n\nThe `not` constraint allows you to check that particular `fact` does **not** exist.\n\n```javascript\n\n[\n    [Number, \"n1\"],\n    [\"not\", Number, \"n2\", \"n1 > n2\"]\n]\n\n```\n\nOr using the DSL.\n\n```\n\nwhen {\n    n1: Number;\n    not(n2: Number n1 > n2);\n}\n\n```\n\nThe previous example will check that for all numbers in the `workingMemory` there is **not** one that is greater than `n1`.\n\n<a name=\"or-constraint\"></a>\n#### Or Constraint\n\nThe `or` constraint can be used to check for the existence of multiple facts.\n\n```javascript\n\n[\n    [\"or\",\n        [String, \"s\", \"s == 'hello'\"],\n        [String, \"s\", \"s == 'world'\"],\n        [String, \"s\", \"s == 'hello world'\"]\n    ]\n]\n\n```\n\nUsing the DSL.\n\n```\nwhen {\n    or(\n        s : String s == 'hello',\n        s : String s == 'world',\n        s : String s == 'hello world'\n    );\n}\n```\n\nThe previous example will evaluate to `true` if you have a string in `workingMemory` that equals `hello`, `world, or 'hello world`.\n\n**Or with Not**\n\nThe `or` constraint can be combined with a `not` constraint to allow for the checking of multiple not conditions without the implcit and.\n\n```javascript\nvar flow = nools.flow(\"or condition with not conditions\", function (flow) {\n        flow.rule(\"hello rule\", [\n                [\"or\",\n                    [\"not\", Number, \"n1\", \"n1 == 1\"],\n                    [\"not\", String, \"s1\", \"s1 == 'hello'\"],\n                    [\"not\", Date, \"d1\", \"d1.getDate() == now().getDate()\"]\n                ],\n                [Count, \"called\", null]\n            ], function (facts) {\n                facts.called.called++;\n            });\n        });\n});\n```\nor using the dsl.\n\n```\nrule MultiNotOrRule {\n    when {\n        or (\n            not(n1: Number n1 == 1),\n            not(s1: String s1 == 'hello'),\n            not(d1: Date d1.getDate() == now().getDate())\n        );\n        c: Count;\n    }\n    then{\n        c.called++;\n    }\n}\n```\n\n**Note** Using the `or` with a `not` will cause the activation to fire for each `not` condition that passes. In the above examples if none of the three facts existed then the rule would fire three times.\n\n<a name=\"from-constraint\"></a>\n#### From Constraint\n\nThe `from` modifier allows for the checking of facts that are not necessarily in the `workingMemory`.\n\nThe `from` modifier can be used to access properties on a `fact` in `workingMemory` or you can use javascript expressions.\n\nTo access properties on a fact you can use the fact name and the property you wish to use as the source for the `from` source.\n\n```javascript\n[\n    [Person, \"p\"],\n    [Address, \"a\", \"a.zipcode == 88847\", \"from p.address\"],\n    [String, \"first\", \"first == 'bob'\", \"from p.firstName\"],\n    [String, \"last\", \"last == 'yukon'\", \"from p.lastName\"]\n]\n```\n\nOr using the DSL.\n\n```\nwhen {\n    p: Person:\n    a: Address a.zipcode == 88847 from p.address;\n    first: String first == 'bob' from p.firstName;\n    last: String last == 'yukon' from p.lastName;\n}\n```\n\nThe above example will used the address, firstName and lastName from the `person` fact.\n\nYou can also use the `from` modifier to check facts that create a graph.\n\nFor example assume the person object from above has friends that are also of type `Person`.\n\n```javascript\n[\n    [Person, \"p\"],\n    [Person, \"friend\", \"friend.firstName != p.firstName\", \"from p.friends\"],\n    [String, \"first\", \"first =~ /^a/\", \"from friend.firstName\"]\n]\n```\n\nOr using the DSL.\n\n```\nwhen {\n    p: Person;\n    friend: Person friend.firstName != p.firstName from p.friends;\n    first: String first =~ /^a/ from friend.firstName;\n}\n```\n\nThe above example will pull the `friend` fact from the friends array property on fact `p`, and first from the `friend`'s `firstName`.\n\nYou could achieve the same thing using the following code if you assert all friends into working memory.\n\n```\nwhen {\n    p: Person;\n    friend: Person friend in p.friends && friend.firstName != p.firstName && p.firstName =~ /^a/;\n}\n```\n\n\nTo specify the from source as an expression you can do the following.\n\n```javascript\n[\n    [Number, \"n1\", \"from [1,2,3,4,5]\"]\n]\n```\n\nOr using the dsl\n\n```\n{\n    n1: Number from [1,2,3,4,5];\n}\n```\n\nUsing the above syntax you could use `from` to bootstrap data.\n\nYou can also use any function defined in the scope of the `rule` or `flow`\n\n```javascript\n\nflow.rule(\"my rule\", {\n    scope: {\n        myArr: function(){\n            return [1,2,3,4,5];\n        }\n    },\n    [Number, \"n1\", \"from myArr()\"],\n    function(facts){\n        this.assert(facts.n1);\n    }\n}\n\n```\n\nOr using the dsl and the [scope](#rule-scope) option.\n\n```\nrule \"my rule\", {\n    when {\n        n1: Number from myArr();\n    }\n    then{\n        assert(n1);\n    }\n}\n```\n\n<a name=\"exists-constraint\"></a>\n\n###Exists Constraint\n\n`exists` is the logical inversion of a `not` constraint. It checks for the existence of a fact in memory.\n\n **NOTE** If there are multiple facts that satisfy the constraint the rule will **ONLY** be fired once.\n\n ```javascript\n\n [\n     [\"exists\", Number, \"n1\", \"n1 > 1\"]\n ]\n\n ```\n\n Or using the DSL.\n\n ```\n\n when {\n     exists(n1: Number n1 > 1);\n }\n\n ```\n\n Assuming the above constraint. The following facts would cause the rule to fire once since there is a number that is greater than 1.\n\n ```javascript\n session.assert(1);\n session.assert(2);\n session.assert(3);\n session.assert(4);\n session.assert(5);\n ```\n\n<a name=\"action\"></a>\n\n### Action\n\nThe action is a function that should be fired when all patterns in the rule match. The action is called in the scope\nof the engine so you can use `this` to `assert`, `modify`, or `retract` facts. An object containing all facts and\nreferences created by the alpha nodes is passed in as the first argument to the action.\n\nSo calculate's action modifies f3 by adding the value of f1 and f2 together and modifies f3 and retracts f1.\n\n```javascript\nfunction (facts) {\n        var f3 = facts.f3, f1 = facts.f1, f2 = facts.f2;\n        var v = f3.value = f1.value + facts.f2.value;\n        facts.r.result = v;\n        this.modify(f3);\n        this.retract(f1);\n    }\n```\n\nThe session is also passed in as a second argument so alternatively you could do the following.\n\n```javascript\nfunction (facts, session) {\n        var f3 = facts.f3, f1 = facts.f1, f2 = facts.f2;\n        var v = f3.value = f1.value + facts.f2.value;\n        facts.r.result = v;\n        session.modify(f3);\n        session.retract(f1);\n    }\n```\n\nTo define the actions with the nools DSL\n\n```\nthen {\n    modify(f3, function(){\n        this.value = f1.value + f2.value;\n    });\n    retract(f1);\n}\n```\n\nFor rules defined using the rules language nools will automatically determine what parameters need to be passed in based on what is referenced in the action.\n\n\n<a name=\"action-async\"></a>\n\n### Async Actions\n\nIf your action is async you can use the third argument which should be called when the action is completed.\n\n```javascript\nfunction (facts, engine, next) {\n        //some async action\n        process.nextTick(function(){\n            var f3 = facts.f3, f1 = facts.f1, f2 = facts.f2;\n            var v = f3.value = f1.value + facts.f2.value;\n            facts.r.result = v;\n            engine.modify(f3);\n            engine.retract(f1);\n            next();\n        });\n    }\n```\n\nIf an error occurs you can pass the error as the first argument to `next`.\n\n```javascript\nthen{\n   saveToDatabase(user, function(err){\n      next(new Error(\"Something went BOOM!\"));\n   });\n}\n```\n\nIf you are using a [`Promises/A+`](http://promises-aplus.github.io/promises-spec/) compliant library you can just return a promise from your action and `nools` will wait for the promise to resolve before continuing.\n\n```javascript\nthen{\n   return saveToDatabase(user); // assume saveToDatabase returns a promise\n}\n```\n\n<a name=\"globals\"></a>\n\n### Globals\n\nGlobals are accessible through the current working scope of rules defined in a `dsl`, very similar to using the `scope` option when compiling.\n\n**Note**  `globals` are not part of the working memory and therefore are not accessible in the LHS (when) or your rule.\n\nGlobals are used like the following:\n\n```\nglobal PI = Math.PI;\nglobal SOME_STRING = 'some string';\nglobal TRUE = true;\nglobal NUM = 1.23;\nglobal DATE = new Date();\n\nrule \"A Rule\" {\n    when {\n    \t$obj: Object;\n    }\n    then{\n    \tconsole.log(PI); //Math.PI;\n    \tconsole.log(SOME_STRING); //\"some string\"\n    \tconsole.log(TRUE); //true\n    \tconsole.log(NUM); //1.23\n    \tconsole.log(DATE); //Thu May 23 2013 15:49:22 GMT-0500 (CDT)\n    }\n}\n```\n\nIf you are using `nools` in `node` you can also use a require statement.\n\n**NOTE** require does not currently work for relative paths.\n\n```\nglobal util = require(\"util\");\n\nrule \"A Rule\" {\n    when {\n    \t$obj: Object;\n    }\n    then{\n    \tutil.log(\"HELLO WORLD\");\n    }\n}\n```\n\n<a name=\"import\"></a>\n\n### Importing\n\nThe `import` statement allows you to import other `nools` files into the current one. This can be used to split up logical flows into small reusable groups of rules.\n\nDefine our common model to be used across our flows.\n\n```\n//define.nools\ndefine Count{\n    constructor: function(){\n        this.called = 0;\n    }\n}\n```\n\nCreate a rules file which imports the `define.nools` to define our `Count` model.\n\n```\n//orRule.nools\n\n//import define.nools\nimport(\"./define.nools\");\nrule orRule {\n    when {\n        or(\n            s : String s == 'hello',\n            s : String s == 'world'\n        );\n        count : Count;\n    }\n    then {\n        count.called++;\n        count.s = s;\n    }\n}\n```\n\nSame as `orRule.nools` import our `define.nools`\n\n```\n//notRule.nools\nimport(\"./defines.nools\");\nrule notRule {\n    when {\n        not(s : String s == 'hello');\n        count : Count\n    }\n    then {\n        count.called++;\n    }\n}\n```\n\nNow we can use `orRule.nools` and `notRule.nools` to compose a new flow that contains `define.nools`, `orRule.nools` and `notRule.nools`.\n\n\n**Note** `nools` will handle duplicate imports, in this case `define.nools` will only be imported once.\n\n```\n//import\nimport(\"./orRules.nools\");\nimport(\"./notRules.nools\");\n```\n\n\n## Emitting custom events.\n\nYou may also emit events from your rule actions using the sessions emit function.\n\n```\nthen {\n    modify(f3, function(){\n        this.value = f1.value + f2.value;\n    });\n    retract(f1);\n    emit(\"my custom event\");\n}\n```\n\nTo listen to the event just use the on method of the session.\n\n```\nvar session = flow.getSession();\n\nsession.on(\"my custom event\", function(){\n    //custom event called.\n});\n\n```\n\n# Browser Support\n\n<a name=\"browser-support\"></a>\n\n`Nools` can also be used in the browser. The only difference is that you cannot pass a file location to the compile method instead you must provide the source.\n\nNools is compatible with amd(requirejs) and can also be used in a standard script tag.\n\n### Example 1.\n\nIn this example we compile rules definitions inlined in a script tag.\n\n```html\n<script type=\"text/javascript\" src=\"nools.js\"></script>\n<script type=\"text/nools\" id=\"simple\">\ndefine Message {\n    message : \"\",\n    constructor : function (message) {\n        this.text = message;\n    }\n}\n\nrule Hello {\n    when {\n        m : Message m.text =~ /^hello(\\\\s*world)?$/\n    }\n    then {\n        modify(m, function(){\n            this.text += \" goodbye\";\n        });\n    }\n}\n\nrule Goodbye {\n    when {\n        m : Message m.text =~ /.*goodbye$/\n    }\n    then {\n        document.getElementById(\"output\").innerHTML += m.text + \"</br>\";\n    }\n}\n</script>\n<script type=\"text/javascript\">\n    function init() {\n       //get the source\n       var source = document.getElementById(\"simple\").innerHTML;\n       //compile the source. The name option is required if compiling directly.\n       var flow = nools.compile(source, {name: \"simple\"}),\n                Message = flow.getDefined(\"message\"),\n                session = flow.getSession();\n        //assert your different messages\n        session.assert(new Message(\"goodbye\"));\n        session.assert(new Message(\"hello\"));\n        session.assert(new Message(\"hello world\"));\n        session.match();\n    }\n</script>\n```\n\n### Using a compiled dsl.\n\nYou may also use the `nools` executable to compile source into a browser friendly format skipping the need for compiling each time.\n\n```\nnools compile ./my/rules.nools > ./compiled.js\n```\n\nTo use the flow require the compile version either through a script tag, `amd/requirejs`, or `commonjs` require.\n\nIf you import the flow using a script tag you can get a reference to the flow by using `nools.getFlow`.\n\n```\nnools.getFlow(\"rules\");\n```\n\nYou may also specify the name of the flow when compiling, it defaults to the name of the nools file less \".nools\"\n\n```\nnools compile -n \"my rules\" ./my/rules.nools\n```\n\n```\nnools.getFlow(\"my rules\");\n```\n\nIf you are using requirejs or nools must be required using something other than `require(\"nools\")` then you can specify a location of the nools source.\n\n```\nnools compile -nl \"./location/to/nools\" ./my/rules.nools\n```\n\n### RequireJS examples\n\nExamples of using nools with require js are located in the [examples directory](./examples).\n\n\n\n# Examples\n\n<a name=\"fib\"></a>\n## Fibonacci\n\n```javascript\n\"use strict\";\n\nvar nools = require(\"nools\");\n\nvar Fibonacci = function (sequence, value) {\n    this.sequence = sequence;\n    this.value = value || -1;\n};\n\nvar Result = function (result) {\n    this.result = result || -1;\n};\n\n\nvar flow = nools.flow(\"Fibonacci Flow\", function (flow) {\n\n    flow.rule(\"Recurse\", [\n        [\"not\", Fibonacci, \"f\", \"f.sequence == 1\"],\n        [Fibonacci, \"f1\", \"f1.sequence != 1\"]\n    ], function (facts) {\n        var f2 = new Fibonacci(facts.f1.sequence - 1);\n        this.assert(f2);\n    });\n\n    flow.rule(\"Bootstrap\", [\n          Fibonacci, \"f\", \"f.value == -1 && (f.sequence == 1 || f.sequence == 2)\"\n    ], function (facts) {\n        var f = facts.f;\n        f.value = 1;\n        this.modify(f);\n    });\n\n    flow.rule(\"Calculate\", [\n        [Fibonacci, \"f1\", \"f1.value != -1\", {sequence:\"s1\"}],\n        [Fibonacci, \"f2\", \"f2.value != -1 && f2.sequence == s1 + 1\", {sequence:\"s2\"}],\n        [Fibonacci, \"f3\", \"f3.value == -1 && f3.sequence == s2 + 1\"],\n        [Result, \"r\"]\n    ], function (facts) {\n        var f3 = facts.f3, f1 = facts.f1, f2 = facts.f2;\n        var v = f3.value = f1.value + facts.f2.value;\n        facts.r.result = v;\n        this.modify(f3);\n        this.retract(f1);\n    });\n});\n\nvar r1 = new Result(),\n    session1 = flow.getSession(new Fibonacci(10), r1),\n    s1 = new Date;\nsession1.match().then(function () {\n    console.log(\"%d [%dms]\", r1.result, new Date - s1);\n    session1.dispose();\n});\n\nvar r2 = new Result(),\n    session2 = flow.getSession(new Fibonacci(150), r2),\n    s2 = new Date;\nsession2.match().then(function () {\n    console.log(\"%d [%dms]\", r2.result, new Date - s2);\n    session2.dispose();\n});\n\nvar r3 = new Result(),\n    session3 = flow.getSession(new Fibonacci(1000), r3),\n    s3 = new Date;\nsession3.match().then(function () {\n    console.log(\"%d [%dms]\", r3.result, new Date - s3);\n    session3.dispose();\n});\n\n```\n\nOutput\n\n```\n55 [43ms]\n9.969216677189305e+30 [383ms]\n4.346655768693743e+208 [3580ms]\n```\n\n### Fibonacci with nools DSL\n\n```\n//Define our object classes, you can\n//also declare these outside of the nools\n//file by passing them into the compile method\ndefine Fibonacci {\n    value:-1,\n    sequence:null\n}\ndefine Result {\n    value : -1\n}\n\nrule Recurse {\n    when {\n        //you can use not or or methods in here\n        not(f : Fibonacci f.sequence == 1);\n        //f1 is how you can reference the fact else where\n        f1 : Fibonacci f1.sequence != 1;\n    }\n    then {\n        assert(new Fibonacci({sequence : f1.sequence - 1}));\n    }\n}\n\nrule Bootstrap {\n   when {\n       f : Fibonacci f.value == -1 && (f.sequence == 1 || f.sequence == 2);\n   }\n   then{\n       modify(f, function(){\n           this.value = 1;\n       });\n   }\n}\n\nrule Calculate {\n    when {\n        f1 : Fibonacci f1.value != -1 {sequence : s1};\n        //here we define constraints along with a hash so you can reference sequence\n        //as s2 else where\n        f2 : Fibonacci f2.value != -1 && f2.sequence == s1 + 1 {sequence:s2};\n        f3 : Fibonacci f3.value == -1 && f3.sequence == s2 + 1;\n        r : Result\n    }\n    then {\n        modify(f3, function(){\n            this.value = r.result = f1.value + f2.value;\n        });\n        retract(f1);\n    }\n}\n\n```\n\nAnd to run\n\n```javascript\nvar flow = nools.compile(__dirname + \"/fibonacci.nools\");\n\nvar Fibonacci = flow.getDefined(\"fibonacci\"), Result = flow.getDefined(\"result\");\nvar r1 = new Result(),\n    session1 = flow.getSession(new Fibonacci({sequence:10}), r1),\n    s1 = +(new Date());\nsession1.match().then(function () {\n    console.log(\"%d [%dms]\", r1.result, +(new Date()) - s1);\n    session1.dispose();\n});\n\nvar r2 = new Result(),\n    session2 = flow.getSession(new Fibonacci({sequence:150}), r2),\n    s2 = +(new Date());\nsession2.match().then(function () {\n    console.log(\"%d [%dms]\", r2.result, +(new Date()) - s2);\n    session2.dispose();\n});\n\nvar r3 = new Result(),\n    session3 = flow.getSession(new Fibonacci({sequence:1000}), r3),\n    s3 = +(new Date());\nsession3.match().then(function () {\n    console.log(\"%d [%dms]\", r3.result, +(new Date()) - s3);\n    session3.dispose();\n});\n\n```\n\nLicense\n-------\n\nMIT <https://github.com/C2FO/nools/raw/master/LICENSE>\n\nMeta\n----\n\n* Code: `git clone git://github.com/C2FO/nools.git`\n",
  "readmeFilename": "readme.md",
  "bugs": {
    "url": "https://github.com/C2FO/nools/issues"
  },
  "_id": "nools@0.3.0",
  "dist": {
    "shasum": "ec1eec2803355a5f6e9bf0331be17a77da775c46"
  },
  "_from": "nools@*",
  "_resolved": "https://registry.npmjs.org/nools/-/nools-0.3.0.tgz"
}
